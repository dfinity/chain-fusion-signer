{"version":3,"file":"certificate.js","sourceRoot":"","sources":["../../src/certificate.ts"],"names":[],"mappings":"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","sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\nimport { decodeTime } from './utils/leb';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\nexport interface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nconst NodeId = {\n  Empty: 0,\n  Fork: 1,\n  Labeled: 2,\n  Leaf: 3,\n  Pruned: 4,\n};\n\nexport type NodeIdType = typeof NodeId[keyof typeof NodeId];\n\nexport { NodeId };\n\nexport type HashTree =\n  | [typeof NodeId.Empty]\n  | [typeof NodeId.Fork, HashTree, HashTree]\n  | [typeof NodeId.Labeled, ArrayBuffer, HashTree]\n  | [typeof NodeId.Leaf, ArrayBuffer]\n  | [typeof NodeId.Pruned, ArrayBuffer];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeId.Empty:\n      return '()';\n    case NodeId.Fork: {\n      if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n        const left = hashTreeToString(tree[1]);\n        const right = hashTreeToString(tree[2]);\n        return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for fork');\n      }\n    }\n    case NodeId.Labeled: {\n      if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n        const label = labelToString(tree[1]);\n        const sub = hashTreeToString(tree[2]);\n        return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n      } else {\n        throw new Error('Invalid tree structure for labeled');\n      }\n    }\n    case NodeId.Leaf: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for leaf');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeId.Pruned: {\n      if (!tree[1]) {\n        throw new Error('Invalid tree structure for pruned');\n      } else if (Array.isArray(tree[1])) {\n        return JSON.stringify(tree[1]);\n      }\n\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, any> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean>;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.\n   */\n  blsVerify?: VerifyFunc;\n\n  /**\n   * The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @default 5\n   * This is used to verify the time the certificate was signed, particularly for validating Delegation certificates, which can live for longer than the default window of +/- 5 minutes. If the certificate is\n   * older than the specified age, it will fail verification.\n   */\n  maxAgeInMinutes?: number;\n}\n\ntype MetricsResult = number | bigint | Map<number, number | bigint> | undefined;\n\nexport class Certificate {\n  private readonly cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs  Certificate\n   * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n      options.maxAgeInMinutes,\n    );\n\n    await cert.verify();\n    return cert;\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n    // Default to 5 minutes\n    private _maxAgeInMinutes: number = 5,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): ArrayBuffer | undefined {\n    // constrain the type of the result, so that empty HashTree is undefined\n    return lookupResultToBuffer(lookup_path(path, this.cert.tree));\n  }\n\n  public lookup_label(label: ArrayBuffer): ArrayBuffer | HashTree | undefined {\n    return this.lookup([label]);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n\n    const lookupTime = this.lookup(['time']);\n    if (!lookupTime) {\n      // Should never happen - time is always present in IC certificates\n      throw new CertificateVerificationError('Certificate does not contain a time');\n    }\n\n    const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n    const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n    const now = Date.now();\n    const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n    const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n\n    const certTime = decodeTime(lookupTime);\n\n    if (certTime.getTime() < earliestCertificateTime) {\n      throw new CertificateVerificationError(\n        `Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    } else if (certTime.getTime() > fiveMinutesFromNow) {\n      throw new CertificateVerificationError(\n        'Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n          certTime.toISOString() +\n          ' Current time: ' +\n          new Date(now).toISOString(),\n      );\n    }\n\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n\n    const cert: Certificate = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n      blsVerify: this._blsVerify,\n      // Do not check max age for delegation certificates\n      maxAgeInMinutes: Infinity,\n    });\n\n    const canisterInRange = check_canister_ranges({\n      canisterId: this._canisterId,\n      subnetId: Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n      tree: cert.cert.tree,\n    });\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nexport function lookupResultToBuffer(\n  result: ArrayBuffer | HashTree | undefined,\n): ArrayBuffer | undefined {\n  if (result instanceof ArrayBuffer) {\n    return result;\n  } else if (result instanceof Uint8Array) {\n    return result.buffer;\n  }\n  return undefined;\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeId.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeId.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeId.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeId.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(\n  path: Array<ArrayBuffer | string>,\n  tree: HashTree,\n): ArrayBuffer | HashTree | undefined {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeId.Leaf: {\n        // should not be undefined\n        if (!tree[1]) throw new Error('Invalid tree structure for leaf');\n        if (tree[1] instanceof ArrayBuffer) {\n          return tree[1];\n        } else if (tree[1] instanceof Uint8Array) {\n          return tree[1].buffer;\n        } else return tree[1];\n      }\n      case NodeId.Fork: {\n        return tree;\n      }\n      default: {\n        return tree;\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\n\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nexport function flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return [];\n    case NodeId.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\n\nfunction find_label(l: ArrayBuffer, trees: HashTree[]): HashTree | undefined {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === NodeId.Labeled) {\n      const p = t[1] as ArrayBuffer;\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}\n\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nexport function check_canister_ranges(params: {\n  canisterId: Principal;\n  subnetId: Principal;\n  tree: HashTree;\n}): boolean {\n  const { canisterId, subnetId, tree } = params;\n  const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n\n  if (!rangeLookup || !(rangeLookup instanceof ArrayBuffer)) {\n    throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n  }\n\n  const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup);\n  const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n    Principal.fromUint8Array(v[0]),\n    Principal.fromUint8Array(v[1]),\n  ]);\n\n  const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n\n  return canisterInRange;\n}\n"]}