type Account = record { owner : principal; subaccount : opt blob };
type Arg = variant { Upgrade; Init : InitArg };
type Bip341 = record { merkle_root_hash : blob };
type BitcoinAddressType = variant { P2WPKH };
type BtcTxOutput = record { destination_address : text; sent_satoshis : nat64 };
type BuildP2wpkhTxError = variant {
  NotEnoughFunds : record { available : nat64; required : nat64 };
  WrongBitcoinNetwork;
  NotP2WPKHSourceAddress;
  InvalidDestinationAddress : GetAddressResponse;
  InvalidSourceAddress : GetAddressResponse;
};
type CallerPaysIcrc2Tokens = record { ledger : principal };
type CanisterStatusResultV2 = record {
  controller : principal;
  status : CanisterStatusType;
  freezing_threshold : nat;
  balance : vec record { blob; nat };
  memory_size : nat;
  cycles : nat;
  settings : DefiniteCanisterSettingsArgs;
  idle_cycles_burned_per_day : nat;
  module_hash : opt blob;
};
type CanisterStatusType = variant { stopped; stopping; running };
type Config = record {
  ecdsa_key_name : text;
  ic_root_key_raw : opt blob;
  cycles_ledger : principal;
};
type DefiniteCanisterSettingsArgs = record {
  controller : principal;
  freezing_threshold : nat;
  controllers : vec principal;
  memory_allocation : nat;
  compute_allocation : nat;
};
type EcdsaCurve = variant { secp256k1 };
type EcdsaKeyId = record { name : text; curve : EcdsaCurve };
type EcdsaPublicKeyArgs = record {
  key_id : EcdsaKeyId;
  canister_id : opt principal;
  derivation_path : vec blob;
};
type EcdsaPublicKeyResult = record { public_key : blob; chain_code : blob };
type EthAddressError = variant {
  SigningError : record { RejectionCode; text };
  PaymentError : PaymentError;
};
type EthAddressRequest = record { "principal" : opt principal };
type EthAddressResponse = record { address : text };
type EthPersonalSignRequest = record { message : text };
type EthPersonalSignResponse = record { signature : text };
type EthSignPrehashRequest = record { hash : text };
type EthSignPrehashResponse = record { signature : text };
type EthSignTransactionRequest = record {
  to : text;
  gas : nat;
  value : nat;
  max_priority_fee_per_gas : nat;
  data : opt text;
  max_fee_per_gas : nat;
  chain_id : nat;
  nonce : nat;
};
type GetAddressError = variant {
  InternalError : record { msg : text };
  PaymentError : PaymentError;
};
type GetAddressRequest = record {
  network : Network;
  address_type : BitcoinAddressType;
};
type GetAddressResponse = record { address : text };
type GetBalanceRequest = record {
  network : Network;
  address_type : BitcoinAddressType;
  min_confirmations : opt nat32;
};
type GetBalanceResponse = record { balance : nat64 };
type HttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec record { text; text };
};
type HttpResponse = record {
  body : blob;
  headers : vec record { text; text };
  status_code : nat16;
};
type InitArg = record {
  ecdsa_key_name : text;
  ic_root_key_der : opt blob;
  cycles_ledger : opt principal;
};
type Network = variant { mainnet; regtest; testnet };
type Outpoint = record { txid : blob; vout : nat32 };
type PatronPaysIcrc2Tokens = record { ledger : principal; patron : Account };
type PaymentError = variant {
  LedgerWithdrawFromError : record {
    error : WithdrawFromError;
    ledger : principal;
  };
  LedgerUnreachable : CallerPaysIcrc2Tokens;
  InvalidPatron;
  LedgerTransferFromError : record {
    error : TransferFromError;
    ledger : principal;
  };
  UnsupportedPaymentType;
  InsufficientFunds : record { needed : nat64; available : nat64 };
};
type PaymentType = variant {
  PatronPaysIcrc2Tokens : PatronPaysIcrc2Tokens;
  AttachedCycles;
  CallerPaysIcrc2Cycles;
  CallerPaysIcrc2Tokens : CallerPaysIcrc2Tokens;
  PatronPaysIcrc2Cycles : Account;
};
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok : GetAddressResponse; Err : GetAddressError };
type Result_1 = variant { Ok : GetBalanceResponse; Err : GetAddressError };
type Result_2 = variant { Ok : SendBtcResponse; Err : SendBtcError };
type Result_3 = variant { Ok : EthAddressResponse; Err : EthAddressError };
type Result_4 = variant { Ok : EthPersonalSignResponse; Err : EthAddressError };
type Result_5 = variant { Ok : EthSignPrehashResponse; Err : EthAddressError };
type Result_6 = variant { Ok : EcdsaPublicKeyResult; Err : EthAddressError };
type Result_7 = variant { Ok : SignWithEcdsaResult; Err : EthAddressError };
type Result_8 = variant { Ok : EcdsaPublicKeyResult; Err : EthAddressError };
type Result_9 = variant { Ok : SignWithEcdsaResult; Err : EthAddressError };
type SchnorrAlgorithm = variant { ed25519; bip340secp256k1 };
type SchnorrAux = variant { bip341 : Bip341 };
type SchnorrKeyId = record { algorithm : SchnorrAlgorithm; name : text };
type SchnorrPublicKeyArgs = record {
  key_id : SchnorrKeyId;
  canister_id : opt principal;
  derivation_path : vec blob;
};
type SendBtcError = variant {
  BuildP2wpkhError : BuildP2wpkhTxError;
  InternalError : record { msg : text };
  PaymentError : PaymentError;
};
type SendBtcRequest = record {
  fee_satoshis : opt nat64;
  network : Network;
  utxos_to_spend : vec Utxo;
  address_type : BitcoinAddressType;
  outputs : vec BtcTxOutput;
};
type SendBtcResponse = record { txid : text };
type SignWithEcdsaArgs = record {
  key_id : EcdsaKeyId;
  derivation_path : vec blob;
  message_hash : blob;
};
type SignWithEcdsaResult = record { signature : blob };
type SignWithSchnorrArgs = record {
  aux : opt SchnorrAux;
  key_id : SchnorrKeyId;
  derivation_path : vec blob;
  message : blob;
};
type TransferFromError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  InsufficientAllowance : record { allowance : nat };
  BadBurn : record { min_burn_amount : nat };
  Duplicate : record { duplicate_of : nat };
  BadFee : record { expected_fee : nat };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  InsufficientFunds : record { balance : nat };
};
type Utxo = record { height : nat32; value : nat64; outpoint : Outpoint };
type WithdrawFromError = variant {
  GenericError : record { message : text; error_code : nat };
  TemporarilyUnavailable;
  InsufficientAllowance : record { allowance : nat };
  Duplicate : record { duplicate_of : nat };
  InvalidReceiver : record { receiver : principal };
  CreatedInFuture : record { ledger_time : nat64 };
  TooOld;
  FailedToWithdrawFrom : record {
    withdraw_from_block : opt nat;
    rejection_code : RejectionCode;
    refund_block : opt nat;
    approval_refund_block : opt nat;
    rejection_reason : text;
  };
  InsufficientFunds : record { balance : nat };
};
service : (Arg) -> {
  // Returns the Bitcoin address of the caller.
  // 
  // # Details
  // - Gets the principal's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Converts the public key to a P2WPKH address.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  btc_caller_address : (GetAddressRequest, opt PaymentType) -> (Result);
  // Returns the Bitcoin balance of the caller's address.
  // 
  // > This method is DEPRECATED. Canister developers are advised to call `bitcoin_get_balance()` on
  // > the Bitcoin (mainnet or testnet) canister.
  // 
  // # Details
  // - Gets the principal's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Converts the public key to a P2WPKH address.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Gets the Bitcoin balance from [the deprecated system Bitcoin API](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_balance)
  // - Costs: See [Bitcoin API fees and pricing](https://internetcomputer.org/docs/current/references/bitcoin-how-it-works#api-fees-and-pricing)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  btc_caller_balance : (GetBalanceRequest, opt PaymentType) -> (Result_1);
  // Creates, signs and sends a BTC transaction from the caller's address.
  // 
  // # Details
  // - Gets the principal's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Converts the public key to a P2WPKH address.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - For every transaction input:
  // - Calls `sign_with_ecdsa(..)` on that input.
  // - Costs: See [Fees for the t-ECDSA production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-ecdsa-production-key)
  // - Sends the transaction with `bitcoin_api::send_transaction(..)`
  // - Costs: See [Bitcoin API fees and pricing](https://internetcomputer.org/docs/current/references/bitcoin-how-it-works#api-fees-and-pricing)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  btc_caller_send : (SendBtcRequest, opt PaymentType) -> (Result_2);
  // Show the canister configuration.
  config : () -> (Config) query;
  // Returns the Ethereum address of a specified user.
  // 
  // If no user is specified, the caller's address is returned.
  // 
  // # Details
  // - Gets the specified user's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Converts the public key to an Ethereum address.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  eth_address : (EthAddressRequest, opt PaymentType) -> (Result_3);
  // Returns the Ethereum address of the caller.
  // 
  // # Details
  // - Gets the caller's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Converts the public key to an Ethereum address.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  eth_address_of_caller : (opt PaymentType) -> (Result_3);
  // Computes an Ethereum signature for a hex-encoded message according to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).
  // 
  // # Details
  // - Formats the message as `\x19Ethereum Signed Message:\n<length><message>`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Hashes the message.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Gets the caller's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Signs the message hash with `management_canister::ecdsa::sign_with_ecdsa(..)`
  // - Costs: See [Fees for the t-ECDSA production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-ecdsa-production-key)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  eth_personal_sign : (EthPersonalSignRequest, opt PaymentType) -> (Result_4);
  // Computes an Ethereum signature for a precomputed hash.
  // 
  // # Details
  // Note: This is the same as `eth_personal_sign` but with a precomputed hash, so ingress message
  // size is small regardless of the message length.
  // 
  // - Gets the caller's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Signs the message hash with `management_canister::ecdsa::sign_with_ecdsa(..)`
  // - Costs: See [Fees for the t-ECDSA production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-ecdsa-production-key)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  eth_sign_prehash : (EthSignPrehashRequest, opt PaymentType) -> (Result_5);
  // Computes an Ethereum signature for an [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) transaction.
  // 
  // # Details
  // - Formats the transaction as an `Eip1559TransactionRequest`.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Hashes the transaction.
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Gets the caller's public key with `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // - Signs the transaction with `management_canister::ecdsa::sign_with_ecdsa(..)`
  // - Costs: See [Fees for the t-ECDSA production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-ecdsa-production-key)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  eth_sign_transaction : (EthSignTransactionRequest, opt PaymentType) -> (
      Result_5,
    );
  // Returns the generic ECDSA public key of the caller.
  // 
  // Note: This is an exact dual of the canister [`ecdsa_public_key`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-ecdsa_public_key) method.  The argument and response types are also the same.
  // 
  // # Warnings
  // - The user supplied derivation path is used as-is.  The caller is responsible for ensuring that
  // unintended sub-keys are not requested.
  // 
  // # Details
  // - Calls `management_canister::ecdsa::ecdsa_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  generic_caller_ecdsa_public_key : (EcdsaPublicKeyArgs, opt PaymentType) -> (
      Result_6,
    );
  // Signs a message using the caller's ECDSA key.
  // 
  // Note: This is an exact dual of the canister [`sign_with_ecdsa`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-sign_with_ecdsa) method.  The argument and response types are also the same.
  // 
  // # Warnings
  // - The user supplied derivation path is used as-is.  The caller is responsible for ensuring that
  // unintended sub-keys are not requested.
  // 
  // # Details
  // - Calls `management_canister::ecdsa::sign_with_ecdsa(..)`
  // - Costs: See [Fees for the t-ECDSA production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-ecdsa-production-key)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  generic_sign_with_ecdsa : (opt PaymentType, SignWithEcdsaArgs) -> (Result_7);
  // API method to get cycle balance and burn rate.
  get_canister_status : () -> (CanisterStatusResultV2);
  // Processes external HTTP requests.
  http_request : (HttpRequest) -> (HttpResponse) query;
  // Returns the Schnorr public key of the caller or specified principal.
  // 
  // Note: This is an exact dual of the canister [`schnorr_public_key`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-schnorr_public_key) method.  The argument and response types are also the same.
  // 
  // # Arguments
  // - `arg`: The same `SchnorrPublicKeyArgument` as the management canister argument.  The semantics
  // are identical but the meaning of the fields in the new context deserve some explanation.
  // - `arg.canister_id`: The principal of the canister or user for which the Chain Fusion Signer
  // has issued the public key.  If `None`, the caller's public key is returned.
  // - `arg.derivation_path`: The derivation path to the public key.  The caller is responsible for
  // ensuring that the derivation path is used to namespace appropriately and to ensure that
  // unintended sub-keys are not requested.  At minimum, it is recommended to use `vec!["NAME OF
  // YOUR APP".into_bytes()]`.  The maximum derivation path length is 254, one less than when
  // calling the management canister.
  // - `arg.key_id`: The ID of the root threshold key to use.  E.g. `key_1` or `test_key_1`.  See <https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#key-derivation>
  // for details.
  // - `payment`: The payment type to use.  If omitted or `None`, it will be assumed that cycles have
  // been attached.
  // 
  // # Warnings
  // - The user supplied derivation path is used as-is.  The caller is responsible for ensuring that
  // derivation paths are used to namespace appropriately and to ensure that unintended sub-keys
  // are not requested.
  // - It is recommended that, at minimum, the derivation path should be `vec!["NAME OF YOUR
  // APP".into_bytes()]`
  // 
  // # Details
  // - Calls `management_canister::schnorr::schnorr_public_key(..)`
  // - Costs: [Execution cycles](https://internetcomputer.org/docs/current/developer-docs/gas-cost#execution)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  schnorr_public_key : (SchnorrPublicKeyArgs, opt PaymentType) -> (Result_8);
  // Signs a message using the caller's Schnorr key.
  // 
  // Note: This is an exact dual of the canister [`sign_with_schnorr`](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-sign_with_schnorr) method.  The argument and response types are also the same.
  // 
  // # Arguments
  // - `arg`: The same `SignWithSchnorrArgument` as the management canister argument.  The semantics
  // are identical but the meaning of the fields in the new context deserve some explanation.
  // - `arg.message`: The data to sign.  Note that if you have a large amount of data, you are
  // probably better off hashing the data and then signing the hash.
  // - `arg.derivation_path`: The derivation path to the public key.  The caller is responsible for
  // ensuring that the derivation path is used to namespace appropriately and to ensure that
  // unintended sub-keys are not requested.  At minimum, it is recommended to use `vec!["NAME OF
  // YOUR APP".into_bytes()]`.  The maximum derivation path length is 254, one less than when
  // calling the management canister.
  // - `arg.key_id`: The ID of the root threshold key to use.  E.g. `key_1` or `test_key_1`.  See <https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#key-derivation>
  // for details.
  // - `payment`: The payment type to use.  If omitted or `None`, it will be assumed that cycles have
  // been attached.
  // 
  // # Warnings
  // - The user supplied derivation path is used as-is.  The caller is responsible for ensuring that
  // derivation paths are used to namespace appropriately and to ensure that unintended sub-keys
  // are not requested.
  // - It is recommended that, at minimum, the derivation path should be `vec!["NAME OF YOUR
  // APP".into_bytes()]`
  // 
  // # Details
  // - Calls `management_canister::schnorr::sign_with_schnorr(..)`
  // - Costs: See [Fees for the t-Schnorr production key](https://internetcomputer.org/docs/current/references/t-sigs-how-it-works#fees-for-the-t-schnorr-production-key)
  // 
  // # Panics
  // - If the caller is the anonymous user.
  schnorr_sign : (SignWithSchnorrArgs, opt PaymentType) -> (Result_9);
}
